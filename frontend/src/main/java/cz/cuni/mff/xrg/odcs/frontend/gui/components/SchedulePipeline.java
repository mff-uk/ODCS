package cz.cuni.mff.xrg.odcs.frontend.gui.components;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import com.vaadin.annotations.AutoGenerated;
import com.vaadin.data.Container;
import com.vaadin.data.Validator;
import com.vaadin.data.Property.ValueChangeEvent;
import com.vaadin.data.Property.ValueChangeListener;
import com.vaadin.data.util.ObjectProperty;
import com.vaadin.event.FieldEvents;
import com.vaadin.ui.Button;
import com.vaadin.ui.Button.ClickListener;
import com.vaadin.ui.CheckBox;
import com.vaadin.ui.ComboBox;
import com.vaadin.ui.GridLayout;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.InlineDateField;
import com.vaadin.ui.Label;
import com.vaadin.ui.OptionGroup;
import com.vaadin.ui.TabSheet;
import com.vaadin.ui.TabSheet.SelectedTabChangeListener;
import com.vaadin.ui.TextArea;
import com.vaadin.ui.TextField;
import com.vaadin.ui.TwinColSelect;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.AbstractTextField.TextChangeEventMode;
import com.vaadin.ui.Button.ClickEvent;
import com.vaadin.ui.Notification;
import com.vaadin.ui.TabSheet.SelectedTabChangeEvent;
import com.vaadin.ui.Window;
import cz.cuni.mff.xrg.odcs.commons.app.auth.AuthenticationContext;
import cz.cuni.mff.xrg.odcs.commons.app.pipeline.DbPipeline;

import cz.cuni.mff.xrg.odcs.commons.app.pipeline.Pipeline;
import cz.cuni.mff.xrg.odcs.commons.app.facade.PipelineFacade;
import cz.cuni.mff.xrg.odcs.commons.app.scheduling.PeriodUnit;
import cz.cuni.mff.xrg.odcs.commons.app.scheduling.Schedule;
import cz.cuni.mff.xrg.odcs.commons.app.facade.ScheduleFacade;
import cz.cuni.mff.xrg.odcs.commons.app.scheduling.ScheduleNotificationRecord;
import cz.cuni.mff.xrg.odcs.commons.app.scheduling.ScheduleType;
import cz.cuni.mff.xrg.odcs.frontend.auxiliaries.SimpleTreeFilter;
import cz.cuni.mff.xrg.odcs.frontend.container.ReadOnlyContainer;
import cz.cuni.mff.xrg.odcs.frontend.container.accessor.PipelineNameAccessor;
import cz.cuni.mff.xrg.odcs.frontend.doa.container.InMemorySource;
import cz.cuni.mff.xrg.odcs.frontend.doa.container.db.DbInMemorySource;
import java.util.Date;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * Dialog for the scheduling rule creation. Designed for setting the description
 * of when the pipeline should be executed.
 *
 * @author Maria Kukhar
 *
 */
public class SchedulePipeline extends Window {

	private static final long serialVersionUID = 1L;
	@AutoGenerated
	private GridLayout coreLayout;
	private HorizontalLayout autoLayout;
	private GridLayout afterLayout;
	private ReadOnlyContainer<Pipeline> container;
	private Container containerCombo;
	private HorizontalLayout inervalEveryLayout;
	private VerticalLayout inervalLayout;
	private TextField pipeFilter;
	private TwinColSelect selectPipe;
	private TextField tfEvery;
	private ComboBox comboEvery;
	private HorizontalLayout toleranceLayout;
	private TextField tfTolerance;
	private VerticalLayout strictlyTimedLayout;
	/**
	 * OptionGroup to set type of pipeline scheduling
	 */
	private OptionGroup scheduleType;
	private CheckBox justOnce;
	private CheckBox strictlyTimed;
	private OptionGroup intervalOption;
	private InlineDateField date;
	private Schedule schedule = null;
	private ObjectProperty<Integer> valueInt;
	private ObjectProperty<Integer> valueTol;
	private Set<Pipeline> afterPipelines = null;
	private Schedule selectSch = null;
	private VerticalLayout mainLayout;
	private TabSheet tabSheet;
	private EmailNotifications emailNotifications;
	private CheckBox notifyThis;
	private EmailComponent email;
	private GridLayout emailLayout;
	private ComboBox comboPipeline = null;
	private TextArea scheduleDescription;
	private boolean isInitialized = false;
	@Autowired
	private DbPipeline dbPipeline;
	@Autowired
	private PipelineFacade pipelineFacade;
	@Autowired
	private ScheduleFacade scheduleFacade;
	@Autowired
	private AuthenticationContext authCtx;
	DbInMemorySource<Pipeline> source;
	DbInMemorySource<Pipeline> sourceCombo;
	private long oldPipelineId = 0;
	private Label id;
	private Label idLabel;
	private Label author;

	/**
	 * The constructor should first build the main layout, set the composition
	 * root and then do any custom initialization.
	 *
	 * The constructor will not be automatically regenerated by the visual
	 * editor.
	 */
	public SchedulePipeline() {
		this.setResizable(false);
		this.setModal(true);
		this.setCaption("Schedule a pipeline");
	}

	/**
	 * Initialize the component.
	 */
	public void init() {
		buildMainLayout();
		this.setContent(mainLayout);
		setSizeUndefined();
		isInitialized = true;
	}

	/**
	 * Is initialized.
	 *
	 * @return If is initialized
	 */
	public boolean isInitialized() {
		return isInitialized;
	}

	/**
	 * Sets the corresponding value of Pipeline to the dialog.
	 *
	 * @param selectedPipeline
	 */
	public void setSelectePipeline(Pipeline selectedPipeline) {
		tabSheet.setSelectedTab(0);

		comboPipeline.setValue(selectedPipeline.getId());
		scheduleDescription.setValue("");
		scheduleType.setValue(ScheduleType.PERIODICALLY);
		date.setValue(new Date());
		justOnce.setValue(false);
		intervalOption.setValue(PeriodUnit.DAY);
		strictlyTimed.setValue(false);
		comboEvery.setValue(PeriodUnit.DAY);
		valueInt.setValue(1);
		valueTol.setValue(1);
		notifyThis.setValue(true);
		emailNotifications.getDefaultScheduleNotificationRecord();
		email.getUserEmailNotification(authCtx.getUser());
		emailNotifications.setDisableComponents();

		source.loadData(dbPipeline);
		sourceCombo.loadData(dbPipeline);
		source.hide(selectedPipeline.getId(), true);
		if (selectPipe != null) {
			selectPipe.setValue(null);
		}

	}

	/**
	 * Selects given schedule and displays it.
	 *
	 * @param selectedSchedule
	 */
	public void setSelectedSchedule(Schedule selectedSchedule) {
		tabSheet.setSelectedTab(0);

		if (selectedSchedule == null) {
			selectSch = null;
			scheduleDescription.setValue("");
			setIdValue(null);
			author.setValue(authCtx.getUsername());
			comboPipeline.setValue(null);
			scheduleType.setValue(ScheduleType.PERIODICALLY);
			date.setValue(new Date());
			justOnce.setValue(false);
			intervalOption.setValue(PeriodUnit.DAY);
			strictlyTimed.setValue(false);
			comboEvery.setValue(PeriodUnit.DAY);
			valueInt.setValue(1);
			valueTol.setValue(1);
			notifyThis.setValue(true);
			emailNotifications.getDefaultScheduleNotificationRecord();
			email.getUserEmailNotification(authCtx.getUser());
			emailNotifications.setDisableComponents();
			source.loadData(dbPipeline);
			sourceCombo.loadData(dbPipeline);

			if (selectPipe != null) {
				selectPipe.setValue(null);
			}

		} else {

			//setting name
			scheduleDescription.setValue(selectedSchedule.getDescription());
			setIdValue(selectedSchedule.getId());
			//setting pipeline
			comboPipeline.setValue(selectedSchedule.getPipeline().getId());
			//setting scheduling rule type
			scheduleType.setValue(selectedSchedule.getType());
			author.setValue(selectedSchedule.getOwner().getUsername());
			//PERIODICALLY type
			if (selectedSchedule.getType().equals(ScheduleType.PERIODICALLY)) {
				//setting the date
				date.setValue(selectedSchedule.getFirstExecution());
				//setting just ones parameter
				if (selectedSchedule.isJustOnce()) {
					justOnce.setValue(true);

				} //setting period of repeat
				else {
					justOnce.setValue(false);
					if (((selectedSchedule.getPeriodUnit().equals(PeriodUnit.DAY))
							|| (selectedSchedule.getPeriodUnit()
							.equals(PeriodUnit.WEEK)) || (selectedSchedule
							.getPeriodUnit().equals(PeriodUnit.MONTH)))
							&& (selectedSchedule.getPeriod().equals(1))) {
						intervalOption.setValue(selectedSchedule.getPeriodUnit());
					} else {
						intervalOption.setValue("every");
						comboEvery.setValue(selectedSchedule.getPeriodUnit());
						valueInt.setValue(selectedSchedule.getPeriod());
					}

				}

				strictlyTimed.setValue(selectedSchedule.isStrictlyTimed());
				if (selectedSchedule.isStrictlyTimed()) {
					valueTol.setValue(selectedSchedule.getStrictToleranceMinutes());
				}
				source.loadData(dbPipeline);
				sourceCombo.loadData(dbPipeline);

			} //AFTER_PIPELINE type
			else {
				//setting after_pipeline list 
				Set<Pipeline> after = selectedSchedule.getAfterPipelines();
				List<Long> afterNames = new ArrayList<>();
				for (Pipeline afteritem : after) {
					afterNames.add(afteritem.getId());
				}
				selectPipe.setValue(afterNames);
				source.loadData(dbPipeline);
				sourceCombo.loadData(dbPipeline);
				source.hide(selectedSchedule.getPipeline().getId(), true);

			}

			if (selectedSchedule.getNotification() != null) {
				notifyThis.setValue(false);
				emailNotifications.getScheduleNotificationRecord(selectedSchedule);
				email.getScheduleEmailNotification(selectedSchedule);
			} else {
				notifyThis.setValue(true);
				emailNotifications.getDefaultScheduleNotificationRecord();
				email.getUserEmailNotification(authCtx.getUser());
				emailNotifications.setDisableComponents();

			}

			selectSch = selectedSchedule;
		}

	}

	/**
	 * Builds main layout contains pipeline, the type of pipeline scheduling,
	 * layouts with components for setting each of the type.
	 *
	 * @return mainLayout GridLayout with all dialog components
	 */
	@AutoGenerated
	private VerticalLayout buildMainLayout() {

		mainLayout = new VerticalLayout();
		mainLayout.setImmediate(false);
		mainLayout.setSpacing(true);

		tabSheet = new TabSheet();
		tabSheet.setImmediate(true);

		tabSheet.addSelectedTabChangeListener(new SelectedTabChangeListener() {
			private static final long serialVersionUID = 1L;

			@Override
			public void selectedTabChange(SelectedTabChangeEvent event) {

				if (event.getTabSheet().getSelectedTab().equals(coreLayout)) {

					tabSheet.setWidth(570, Unit.PIXELS);
				} else {
					tabSheet.setWidth(440, Unit.PIXELS);
				}

			}
		});

		coreLayout = new GridLayout(1, 4);
		coreLayout.setImmediate(false);
		coreLayout.setSpacing(true);
		coreLayout.setMargin(true);

		source = new DbInMemorySource<>(new PipelineNameAccessor(), dbPipeline);
		container = new ReadOnlyContainer<>(source);

		sourceCombo = new DbInMemorySource<>(new PipelineNameAccessor(), dbPipeline);
		containerCombo = new ReadOnlyContainer<>(sourceCombo);

		GridLayout layoutPipeline = new GridLayout(2, 4);
		layoutPipeline.setSpacing(true);
		layoutPipeline.setMargin(false);

		//Pipeline component
		comboPipeline = new ComboBox();
		comboPipeline.setImmediate(true);
		comboPipeline.setContainerDataSource(containerCombo);
		comboPipeline.setNullSelectionAllowed(false);
		comboPipeline.setItemCaptionPropertyId("name");
		//setting mandatory for the pipeline component
		comboPipeline.addValidator(new Validator() {
			private static final long serialVersionUID = 1L;

			@Override
			public void validate(Object value) throws InvalidValueException {
				if (value != null) {
					return;
				}
				throw new InvalidValueException("Pipeline must be filled");
			}
		});

		comboPipeline.addValueChangeListener(new ValueChangeListener() {
			/**
			 * If scheduling type is AFTER_PIPELINE, then refreshing list of
			 * pipelines in the after_pipeline component. It should not contain
			 * selected for scheduling pipeline.
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void valueChange(ValueChangeEvent event) {

				if (event.getProperty().getValue() != null) {

					if (oldPipelineId != 0) {
						source.show(oldPipelineId);
					}
					source.hide((long) event.getProperty().getValue(), true);
					oldPipelineId = (long) event.getProperty().getValue();
				} else {
					if (oldPipelineId != 0) {
						source.show(oldPipelineId);
					}
					oldPipelineId = 0;
				}

				if (scheduleType.getValue().equals(ScheduleType.AFTER_PIPELINE)) {

					coreLayout.removeComponent(0, 3);
					afterLayout = buildAfterLayout();
					coreLayout.addComponent(afterLayout, 0, 3);
				}
			}
		});
		comboPipeline.setWidth("460px");

		idLabel = new Label("ID");
		layoutPipeline.addComponent(idLabel, 0, 3);
		id = new Label("New");
		layoutPipeline.addComponent(id, 1, 3);

		layoutPipeline.addComponent(new Label("Pipeline "), 0, 0);
		layoutPipeline.addComponent(comboPipeline, 1, 0);

		layoutPipeline.addComponent(new Label("Description"), 0, 1);
		scheduleDescription = new TextArea();
		scheduleDescription.setImmediate(true);
		scheduleDescription.setWidth("460px");
		layoutPipeline.addComponent(scheduleDescription, 1, 1);

		layoutPipeline.addComponent(new Label("Schedulled by"), 0, 2);
		author = new Label();
		layoutPipeline.addComponent(author, 1, 2);

		coreLayout.addComponent(layoutPipeline, 0, 0);

		//Schedule type component. Two types: PERIODICALLY and AFTER_PIPELINE
		scheduleType = new OptionGroup();
		scheduleType.setImmediate(true);
		scheduleType.addItem(ScheduleType.PERIODICALLY);
		scheduleType.addItem(ScheduleType.AFTER_PIPELINE);
		scheduleType.setValue(ScheduleType.PERIODICALLY);
		scheduleType
				.setItemCaption(ScheduleType.PERIODICALLY,
						"Schedule the pipeline to run automatically in fixed interval.");
		scheduleType.setItemCaption(ScheduleType.AFTER_PIPELINE,
				"Schedule the pipeline to run after selected pipelines finish.");
		scheduleType.addValueChangeListener(new ValueChangeListener() {
			/**
			 * For each type will be shown corresponding layout with components
			 * for scheduling rule settings.
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void valueChange(ValueChangeEvent event) {

				if (event.getProperty().getValue() == ScheduleType.AFTER_PIPELINE) {

					coreLayout.removeComponent(0, 3);
					afterLayout = buildAfterLayout();
					coreLayout.addComponent(afterLayout, 0, 3);

				} else {
					coreLayout.removeComponent(0, 3);
					coreLayout.addComponent(autoLayout, 0, 3);
				}

			}
		});

		coreLayout.addComponent(scheduleType, 0, 2);
		autoLayout = buildAutoLayout();
		coreLayout.addComponent(autoLayout, 0, 3);

		//Layout with buttons Save and Cancel
		HorizontalLayout buttonBar = new HorizontalLayout();
		buttonBar.setMargin(true);

		//Save button
		Button createRule = new Button();
		createRule.setCaption("Save");
		createRule.setWidth("90px");
		createRule.setImmediate(true);
		createRule.addClickListener(new ClickListener() {
			/**
			 * Checks validation of mandatory fields. Gets settings of
			 * scheduling rule and store record to the Database.
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void buttonClick(ClickEvent event) {

				email.saveEditedTexts();

				String errors = "";
				//pipeline should be filled
				try {
					comboPipeline.validate();

				} catch (Validator.InvalidValueException e) {
					errors = errors + e.getMessage();
				}

				//Interval and Tolerance of PERIODICALLY type should be positive number
				if (scheduleType.getValue().equals(ScheduleType.PERIODICALLY)) {
					try {
						tfEvery.validate();

					} catch (Validator.InvalidValueException e) {
						if (!errors.equals("")) {
							errors = errors + "; Interval value must be a positive integer number, you entered \"" + tfEvery.getValue() + "\"";
						} else {
							errors = errors + "Interval value must be a positive integer number, you entered \"" + tfEvery.getValue() + "\"";
						}
					}

					try {
						tfTolerance.validate();

					} catch (Validator.InvalidValueException e) {
						if (!errors.equals("")) {
							errors = errors + "; Tolerance value must be a positive integer number, you entered \"" + tfTolerance.getValue() + "\"";
						} else {
							errors = errors + "Tolerance value must be a positive integer number, you entered \"" + tfTolerance.getValue() + "\"";
						}
					}

				}
				//selected pipeline in the AFTER_PIPELINE case should be filled.
				if (scheduleType.getValue()
						.equals(ScheduleType.AFTER_PIPELINE)) {
					try {
						selectPipe.validate();

					} catch (Validator.InvalidValueException e) {
						if (!errors.equals("")) {
							errors = errors + "; " + e.getMessage();
						} else {
							errors = errors + e.getMessage();
						}
					}
				}

				if (!errors.equals("")) {
					errors = errors + ".";
					Notification.show("Failed to create scheduler rule.",
							errors + " Please correct that before saving. ", Notification.Type.ERROR_MESSAGE);
					return;
				}

				//checking if the dialog was open from the Scheduler table
				//if no, create new scheduling rule
				if (selectSch == null) {
					schedule = scheduleFacade.createSchedule();
				} else {
					schedule = selectSch;
					selectSch = null;
				}

				Object pipeID = comboPipeline.getValue();

				//setting scheduler parameters
				//setting pipeline
				Pipeline pipe = pipelineFacade.getPipeline((Long) pipeID);
				schedule.setPipeline(pipe);

				//setting description
				if (scheduleDescription.getValue() != null
						&& scheduleDescription.getValue().trim() != null) {
					schedule.setDescription(scheduleDescription.getValue());
				} else {
					schedule.setDescription("");
				}

				//setting type
				schedule.setType((ScheduleType) scheduleType.getValue());

				// Periodically Schedule type selected. Setting parameters.
				if (scheduleType.getValue().equals(ScheduleType.PERIODICALLY)) {
					schedule.setFirstExecution(date.getValue());
					schedule.setJustOnce(justOnce.getValue());
					if (justOnce.getValue().equals(false)) {

						if ((intervalOption.getValue().equals(PeriodUnit.DAY))
								|| (intervalOption.getValue()
								.equals(PeriodUnit.WEEK))
								|| (intervalOption.getValue()
								.equals(PeriodUnit.MONTH))) {

							schedule.setPeriodUnit((PeriodUnit) intervalOption
									.getValue());
							schedule.setPeriod(1);

						} else {
							schedule.setPeriodUnit((PeriodUnit) comboEvery
									.getValue());
							schedule.setPeriod(valueInt.getValue());
						}
					}
					schedule.setStrictlyTimed(strictlyTimed.getValue());
					if (strictlyTimed.getValue().equals(true)) {
						schedule.setStrictToleranceMinutes(valueTol.getValue());
					}

				} // After pipeline Schedule type selected Setting parameters.
				else {
					Set<Object> selectedPipelines = (Set) selectPipe.getValue();
					Iterator<Object> it = selectedPipelines.iterator();
					afterPipelines = new HashSet<>();
					while (it.hasNext()) {
						Object selectPipe = it.next();
						Pipeline item = pipelineFacade.getPipeline((Long) selectPipe);
						afterPipelines.add(item);
					}
					schedule.setAfterPipelines(afterPipelines);
					schedule.setJustOnce(true);
					schedule.setFirstExecution(null);
					schedule.setPeriodUnit(null);
					schedule.setPeriod(null);
				}
				schedule.setEnabled(true);

//				// store scheduling rule record to DB
//				scheduleFacade.save(schedule);
//				Notification.show(String.format("Pipeline %s scheduled successfuly!", schedule.getPipeline().getName()), Notification.Type.HUMANIZED_MESSAGE);
				if (notifyThis.getValue().equals(false)) {

					if (getEmailLayout().isEnabled()) {

						String errorText = emailValidation();

						if (!errorText.equals("")) {
							Notification.show("Failed to save settings, reason:", errorText, Notification.Type.ERROR_MESSAGE);
							return;
						}
					}
					ScheduleNotificationRecord notification = schedule.getNotification();
					if (notification != null) {

						emailNotifications.setScheduleNotificationRecord(notification, schedule);
						email.setScheduleEmailNotification(notification, schedule);
						schedule.setNotification(notification);
					} else {

						ScheduleNotificationRecord scheduleNotificationRecord = new ScheduleNotificationRecord();
						emailNotifications.setScheduleNotificationRecord(scheduleNotificationRecord, schedule);
						email.setScheduleEmailNotification(scheduleNotificationRecord, schedule);
						schedule.setNotification(scheduleNotificationRecord);

					}

					// store scheduling rule record to DB
					scheduleFacade.save(schedule);
					Notification.show(String.format("Pipeline %s scheduled successfuly!", schedule.getPipeline().getName()), Notification.Type.HUMANIZED_MESSAGE);

				} else {
					if (schedule.getNotification() != null) {
						scheduleFacade.deleteNotification(schedule.getNotification());
					} else {
						// store scheduling rule record to DB
						scheduleFacade.save(schedule);
						Notification.show(String.format("Pipeline %s scheduled successfuly!", schedule.getPipeline().getName()), Notification.Type.HUMANIZED_MESSAGE);

					}
				}
				close();

			}
		});

		buttonBar.addComponent(createRule);

		Button cancelButton = new Button("Cancel", new Button.ClickListener() {
			/**
			 * Closes Scheduling pipeline window
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void buttonClick(Button.ClickEvent event) {
				close();

			}
		});
		cancelButton.setWidth("90px");
		buttonBar.addComponent(cancelButton);

		VerticalLayout notificationsLayout = buildnotificationsLayout();

		tabSheet.addTab(coreLayout, "Core", null);
		tabSheet.addTab(notificationsLayout, "Notifications", null);

		mainLayout.addComponent(tabSheet);
		mainLayout.addComponent(buttonBar);
//		mainLayout.setComponentAlignment(buttonBar, Alignment.MIDDLE_RIGHT);

		return mainLayout;
	}

	private VerticalLayout buildnotificationsLayout() {

		VerticalLayout notificationsLayout = new VerticalLayout();
		notificationsLayout.setMargin(true);
		notificationsLayout.setSpacing(true);
		notificationsLayout.setImmediate(true);

		emailNotifications = new EmailNotifications();
		emailNotifications.parentComponentSh = this;
		notificationsLayout = emailNotifications.buildEmailNotificationsLayout();

		email = new EmailComponent();
		setEmailLayout(new GridLayout());
		setEmailLayout(email.initializeEmailList());
		notificationsLayout.addComponent(getEmailLayout());
		email.getUserEmailNotification(authCtx.getUser());

		notifyThis = new CheckBox();
		notifyThis.setImmediate(true);
		notifyThis.setCaption("Use default notification settings");
		notificationsLayout.addComponent(notifyThis, 0);
		emailNotifications.setDisableComponents();
		getEmailLayout().setEnabled(false);
		notifyThis.addValueChangeListener(new ValueChangeListener() {
			private static final long serialVersionUID = 1L;

			@Override
			public void valueChange(ValueChangeEvent event) {

				if (event.getProperty().getValue().equals(true)) {
					emailNotifications.setDisableComponents();

				} else {
					emailNotifications.setEnableComponents();
				}

			}
		});
		notifyThis.setValue(true);

		return notificationsLayout;

	}

	/**
	 * Building layout for the AFTER_PIPELINE scheduling type. Calls from
	 * {@link #buildMainLayout} in case of {@link #scheduleType} is setting as
	 * {@link ScheduleType#AFTER_PIPELINE}
	 *
	 * @return afterLayout GridLayout with components that designed for setting
	 * schedule the pipeline to run after selected pipelines finish.
	 */
	private GridLayout buildAfterLayout() {

		afterLayout = new GridLayout(2, 1);
		afterLayout.setImmediate(false);
//		afterLayout.setHeight("400px");
		afterLayout.setSpacing(true);
		afterLayout.setColumnExpandRatio(0, 0.2f);
		afterLayout.setColumnExpandRatio(1, 0.8f);
		afterLayout.setStyleName("scheduling");

		afterLayout.addComponent(new Label("Select pipeline:"), 0, 0);

		VerticalLayout selectPipelineLayout = new VerticalLayout();
		selectPipelineLayout.setSpacing(true);

		pipeFilter = new TextField();
		pipeFilter.setImmediate(false);
		pipeFilter.setInputPrompt("type to filter pipelines");
		pipeFilter.setWidth("140px");
		pipeFilter.setTextChangeEventMode(TextChangeEventMode.LAZY);
		pipeFilter.addTextChangeListener(new FieldEvents.TextChangeListener() {
			/**
			 * Filtering by pipeline name in the selectPipe component.
			 */
			private static final long serialVersionUID = 1L;
			SimpleTreeFilter filter = null;

			@Override
			public void textChange(final FieldEvents.TextChangeEvent event) {
				Container.Filterable f = (Container.Filterable) selectPipe
						.getContainerDataSource();

				// Remove old filter
				if (filter != null) {
					f.removeContainerFilter(filter);
				}

				// Set new filter
				filter = new SimpleTreeFilter(event.getText(), true, false);
				f.addContainerFilter(filter);

				// update filters 
				source.showAll();

				source.filter(isInitialized, new InMemorySource.Filter<Pipeline>() {
					@Override
					public boolean filter(Pipeline object) {
						return StringUtils.containsIgnoreCase(object.getName(),
								event.getText());
					}
				});

				// refresh the twin container
				container.refresh();
			}
		});

		selectPipelineLayout.addComponent(pipeFilter);

		//Component for pipelines select
		selectPipe = new TwinColSelect();
		//getting all pipelines to the left column
//		for (Pipeline item : pipelines) {
//			if (item.getId() != comboPipeline.getValue()) {
//				selectPipe.addItem(item.getName());
		selectPipe.setContainerDataSource(container);
//			}
//		}

		selectPipe.setNullSelectionAllowed(true);
		selectPipe.setMultiSelect(true);
		selectPipe.setImmediate(true);
		selectPipe.setWidth("400px");
		selectPipe.setHeight("200px");
		selectPipe.setItemCaptionPropertyId("name");
		selectPipe.setLeftColumnCaption("Available pipelines");
		selectPipe.setRightColumnCaption("Selected pipelines");
		//selectPipe is mandatory component 
		selectPipe.addValidator(new Validator() {
			private static final long serialVersionUID = 1L;

			@Override
			public void validate(Object value) throws InvalidValueException {

				if (!value.toString().equals("[]")) {
					return;
				}
				throw new InvalidValueException(
						"Selected pipeline must be filled");

			}
		});

		selectPipelineLayout.addComponent(selectPipe);
		afterLayout.addComponent(selectPipelineLayout, 1, 0);

		return afterLayout;

	}

	/**
	 * Building layout for the PERIODICALLY scheduling type. Calls from
	 * {@link #buildMainLayout} in case of {@link #scheduleType} is setting as
	 * {@link ScheduleType#PERIODICALLY}
	 *
	 * @return autoLayout GridLayout with components that designed for setting
	 * schedule the pipeline to run automatically in fixed interval.
	 */
	@SuppressWarnings({"static-access", "deprecation"})
	private HorizontalLayout buildAutoLayout() {

		autoLayout = new HorizontalLayout();
		autoLayout.setImmediate(true);
		autoLayout.setSpacing(true);
//		autoLayout.setHeight("450px");
		autoLayout.setStyleName("scheduling");

		VerticalLayout firstExecutionLayout = new VerticalLayout();
		firstExecutionLayout.setSpacing(true);

		//Date component
		firstExecutionLayout.addComponent(new Label("Date and time of first execution:"));

		date = new InlineDateField();
		date.setValue(new java.util.Date());
		date.setResolution(date.RESOLUTION_SEC);
		firstExecutionLayout.addComponent(date);

		//Just ones component. Used if the pipeline will be run only ones
		justOnce = new CheckBox();
		justOnce.setCaption("Just once");
		justOnce.setValue(false);
		justOnce.setImmediate(true);
		justOnce.addValueChangeListener(new ValueChangeListener() {
			/**
			 * If justOnce is selected then the OptionGroup inervalLayout is
			 * disabled.
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void valueChange(ValueChangeEvent event) {
				if (event.getProperty().getValue().equals(true)) {
					inervalLayout.setEnabled(false);
					if (!tfEvery.isValid()) {
						tfEvery.setValue("1");
					}
				} else {
					inervalLayout.setEnabled(true);
				}

			}
		});

		firstExecutionLayout.addComponent(justOnce);

		VerticalLayout dateIntervalLayout = new VerticalLayout();
		dateIntervalLayout.setSpacing(true);

		dateIntervalLayout.addComponent(new Label("Interval:"));

		//OptionGroup with an interval 
		inervalLayout = new VerticalLayout();
		intervalOption = new OptionGroup();
		intervalOption.setImmediate(true);
		intervalOption.addItem(PeriodUnit.DAY);
		intervalOption.setItemCaption(PeriodUnit.DAY, "every day");
		intervalOption.addItem(PeriodUnit.WEEK);
		intervalOption.setItemCaption(PeriodUnit.WEEK, "every week");
		intervalOption.addItem(PeriodUnit.MONTH);
		intervalOption.setItemCaption(PeriodUnit.MONTH, "every month");
		intervalOption.addItem("every");
		intervalOption.setValue(PeriodUnit.DAY);
		intervalOption.addValueChangeListener(new ValueChangeListener() {
			/**
			 * If selected "every" then will be enable component for setting
			 * nonstandard interval.
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void valueChange(ValueChangeEvent event) {

				if (event.getProperty().getValue().toString().equals("every")) {

					comboEvery.setEnabled(true);
					tfEvery.setEnabled(true);

				} else {

					comboEvery.setEnabled(false);
					if (!tfEvery.isValid()) {
						tfEvery.setValue("1");
					}
					tfEvery.setEnabled(false);
				}

			}
		});
		inervalLayout.addComponent(intervalOption);

		//layout for the component for setting nonstandard interval.
		//contains text field for setting numbers and combobox with period values.
		inervalEveryLayout = new HorizontalLayout();
		inervalEveryLayout.setSpacing(true);
		inervalEveryLayout.setMargin(true);

		valueInt = new ObjectProperty<>(1);
		tfEvery = new TextField(valueInt);
		tfEvery.setConverter(Integer.class);
		tfEvery.setWidth("50px");
		tfEvery.setImmediate(true);
		tfEvery.setEnabled(false);
		tfEvery.addValidator(new Validator() {
			private static final long serialVersionUID = 1L;

			@Override
			public void validate(Object val) throws InvalidValueException {
				if (((Integer) val != null) && ((Integer) val > 0)) {
					return;
				}
				throw new InvalidValueException("Value must be positive");

			}
		});

		inervalEveryLayout.addComponent(tfEvery);

		comboEvery = new ComboBox();
		comboEvery.setNullSelectionAllowed(false);
		comboEvery.setImmediate(true);
		comboEvery.addItem(PeriodUnit.MINUTE);
		comboEvery.setItemCaption(PeriodUnit.MINUTE, "Minutes");
		comboEvery.addItem(PeriodUnit.HOUR);
		comboEvery.setItemCaption(PeriodUnit.HOUR, "Hours");
		comboEvery.addItem(PeriodUnit.DAY);
		comboEvery.setItemCaption(PeriodUnit.DAY, "Days");
		comboEvery.addItem(PeriodUnit.MONTH);
		comboEvery.setItemCaption(PeriodUnit.MONTH, "Months");
		comboEvery.setValue(PeriodUnit.DAY);
		comboEvery.setEnabled(false);
		comboEvery.setTextInputAllowed(false);

		inervalEveryLayout.addComponent(comboEvery);
		inervalLayout.addComponent(inervalEveryLayout);
		dateIntervalLayout.addComponent(inervalLayout);

		//strictly timed component
		strictlyTimedLayout = new VerticalLayout();
		strictlyTimedLayout.setSpacing(true);

		strictlyTimed = new CheckBox();
		strictlyTimed.setCaption("Strictly Timed");
		strictlyTimed.setValue(false);
		strictlyTimed.setImmediate(true);
		strictlyTimed.addValueChangeListener(new ValueChangeListener() {
			/**
			 * If strictlytimed isn't selected then the tolerance cpmponent is
			 * disabled.
			 */
			private static final long serialVersionUID = 1L;

			@Override
			public void valueChange(ValueChangeEvent event) {
				if (event.getProperty().getValue().equals(false)) {
					toleranceLayout.setEnabled(false);

				} else {

					toleranceLayout.setEnabled(true);

				}

			}
		});

		strictlyTimedLayout.addComponent(strictlyTimed);

		toleranceLayout = new HorizontalLayout();
		toleranceLayout.setSpacing(true);
		toleranceLayout.setEnabled(false);
		toleranceLayout.addComponent(new Label("Tolerance: "));

		valueTol = new ObjectProperty<>(1);
		tfTolerance = new TextField(valueTol);
		tfTolerance.setConverter(Integer.class);
		tfTolerance.setWidth("50px");
		tfTolerance.setImmediate(true);
		tfTolerance.addValidator(new Validator() {
			private static final long serialVersionUID = 1L;

			@Override
			public void validate(Object val) throws InvalidValueException {
				if (((Integer) val != null) && ((Integer) val > 0)) {
					return;
				}
				throw new InvalidValueException("Value must be positive");

			}
		});

		toleranceLayout.addComponent(tfTolerance);

		toleranceLayout.addComponent(new Label("minutes"));

		strictlyTimedLayout.addComponent(toleranceLayout);
		dateIntervalLayout.addComponent(strictlyTimedLayout);

		autoLayout.addComponent(firstExecutionLayout);
		autoLayout.addComponent(new Label(" "));
		autoLayout.addComponent(dateIntervalLayout);

		return autoLayout;

	}

	/**
	 * Creating error message in case of wrong email format or duplicate emails
	 * in Notification tab
	 *
	 * @return String with error message
	 */
	private String emailValidation() {

		String errorText = "";
		String wrongFormat = "";
		String duplicate = "";
		boolean notEmpty = false;
		boolean dupl = true;
		int errorNumber = 0;
		int duplicateNumber = 0;
		List<TextField> duplicateEmails = new ArrayList<>();
		for (TextField emailField : email.listedEditText) {
			if (!emailField.getValue().trim().isEmpty()) {
				notEmpty = true;
				break;
			}
		}

		if (notEmpty) {
			for (TextField emailField : email.listedEditText) {

				try {
					emailField.validate();

				} catch (Validator.InvalidValueException e) {

					if (e.getMessage().equals("wrong е-mail format")) {
						if (errorNumber == 0) {
							wrongFormat = "\"" + emailField.getValue() + "\"";
						} else {
							wrongFormat = wrongFormat + ", " + "\"" + emailField.getValue() + "\"";
						}
						errorNumber++;
					}
					if (e.getMessage().equals("duplicate e-mail")) {

						if (duplicateNumber == 0) {
							duplicate = "\"" + emailField.getValue() + "\"";
							duplicateEmails.add(emailField);
							duplicateNumber++;

						} else {

							for (TextField duplicateField : duplicateEmails) {
								if (emailField.getValue().equals(duplicateField.getValue())) {
									dupl = false;
									break;
								}
							}
							if (dupl) {
								duplicate = duplicate + ", " + "\"" + emailField.getValue() + "\"";
								duplicateEmails.add(emailField);
								duplicateNumber++;
							}
							dupl = true;
						}

					}
				}
			}
			if (errorNumber == 1) {
				errorText = "Email " + wrongFormat + " has wrong format. ";
			}
			if (errorNumber > 1) {
				errorText = "Emails " + wrongFormat + ", have wrong format. ";
			}
			if (duplicateNumber == 1) {
				errorText = errorText + "Email " + duplicate + " is introduced more times, please correct.";
			}
			if (duplicateNumber > 1) {
				errorText = errorText + "Emails " + duplicate + ", are introduced more times, please correct.";
			}
		} else {
			errorText = "At least one mail has to be filled, so that the notification can be send.";
		}

		return errorText;

	}

	private void setIdValue(Long id) {
		boolean hasId = id != null;
		if (id != null) {
			this.id.setValue(id.toString());
		}
		this.id.setVisible(hasId);
		this.idLabel.setVisible(hasId);
	}

	/**
	 * @return the emailLayout
	 */
	public GridLayout getEmailLayout() {
		return emailLayout;
	}

	/**
	 * @param emailLayout the emailLayout to set
	 */
	public void setEmailLayout(GridLayout emailLayout) {
		this.emailLayout = emailLayout;
	}
}
