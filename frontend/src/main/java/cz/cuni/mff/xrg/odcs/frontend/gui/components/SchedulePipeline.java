/**
 * This file is part of UnifiedViews.
 *
 * UnifiedViews is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * UnifiedViews is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with UnifiedViews.  If not, see <http://www.gnu.org/licenses/>.
 */
package cz.cuni.mff.xrg.odcs.frontend.gui.components;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;

import com.vaadin.annotations.AutoGenerated;
import com.vaadin.data.Container;
import com.vaadin.data.Property.ValueChangeEvent;
import com.vaadin.data.Property.ValueChangeListener;
import com.vaadin.data.Validator;
import com.vaadin.data.util.ObjectProperty;
import com.vaadin.event.FieldEvents;
import com.vaadin.server.Page;
import com.vaadin.ui.AbstractTextField.TextChangeEventMode;
import com.vaadin.ui.*;
import com.vaadin.ui.Button.ClickEvent;
import com.vaadin.ui.Button.ClickListener;
import com.vaadin.ui.TabSheet.SelectedTabChangeEvent;
import com.vaadin.ui.TabSheet.SelectedTabChangeListener;

import cz.cuni.mff.xrg.odcs.commons.app.ScheduledJobsPriority;
import cz.cuni.mff.xrg.odcs.commons.app.auth.AuthenticationContext;
import cz.cuni.mff.xrg.odcs.commons.app.auth.EntityPermissions;
import cz.cuni.mff.xrg.odcs.commons.app.auth.PermissionUtils;
import cz.cuni.mff.xrg.odcs.commons.app.facade.PipelineFacade;
import cz.cuni.mff.xrg.odcs.commons.app.facade.ScheduleFacade;
import cz.cuni.mff.xrg.odcs.commons.app.pipeline.DbPipeline;
import cz.cuni.mff.xrg.odcs.commons.app.pipeline.Pipeline;
import cz.cuni.mff.xrg.odcs.commons.app.scheduling.PeriodUnit;
import cz.cuni.mff.xrg.odcs.commons.app.scheduling.Schedule;
import cz.cuni.mff.xrg.odcs.commons.app.scheduling.ScheduleNotificationRecord;
import cz.cuni.mff.xrg.odcs.commons.app.scheduling.ScheduleType;
import cz.cuni.mff.xrg.odcs.frontend.AppEntry;
import cz.cuni.mff.xrg.odcs.frontend.auxiliaries.SimpleTreeFilter;
import cz.cuni.mff.xrg.odcs.frontend.container.ReadOnlyContainer;
import cz.cuni.mff.xrg.odcs.frontend.container.accessor.PipelineNameAccessor;
import cz.cuni.mff.xrg.odcs.frontend.doa.container.InMemorySource;
import cz.cuni.mff.xrg.odcs.frontend.doa.container.db.DbInMemorySource;
import cz.cuni.mff.xrg.odcs.frontend.i18n.Messages;
import cz.cuni.mff.xrg.odcs.frontend.navigation.ParametersHandler;

/**
 * Dialog for the scheduling rule creation. Designed for setting the description
 * of when the pipeline should be executed.
 *
 * @author Maria Kukhar
 */
public class SchedulePipeline extends Window {

    private static final long serialVersionUID = 1L;

    @AutoGenerated
    private GridLayout coreLayout;

    private HorizontalLayout autoLayout;

    private GridLayout afterLayout;

    private ReadOnlyContainer<Pipeline> container;

    private Container containerCombo;

    private HorizontalLayout inervalEveryLayout;

    private VerticalLayout inervalLayout;

    private TextField pipeFilter;

    private TwinColSelect selectPipe;

    private TextField tfEvery;

    private ComboBox comboEvery;

    private ComboBox priorityComboBox;

    private HorizontalLayout toleranceLayout;

    private VerticalLayout priorityLayout;

    private TextField tfTolerance;

    private VerticalLayout strictlyTimedLayout;

    /**
     * OptionGroup to set type of pipeline scheduling
     */
    private OptionGroup scheduleType;

    private CheckBox justOnce;

    private CheckBox strictlyTimed;

    private OptionGroup intervalOption;

    private InlineDateField date;

    private Schedule schedule = null;

    private ObjectProperty<Integer> valueInt;

    private ObjectProperty<Integer> valueTol;

    private Set<Pipeline> afterPipelines = null;

    private Schedule selectSch = null;

    private VerticalLayout mainLayout;

    private TabSheet tabSheet;

    private EmailNotifications emailNotifications;

    private CheckBox notifyThis;

    private EmailComponent email;

    private GridLayout emailLayout;

    private ComboBox comboPipeline = null;

    private TextArea scheduleDescription;

    private boolean isInitialized = false;

    @Autowired
    private DbPipeline dbPipeline;

    @Autowired
    private PipelineFacade pipelineFacade;

    @Autowired
    private ScheduleFacade scheduleFacade;

    @Autowired
    private AuthenticationContext authCtx;

    @Autowired
    private PermissionUtils permissionUtils;

    DbInMemorySource<Pipeline> source;

    DbInMemorySource<Pipeline> sourceCombo;

    private long oldPipelineId = 0;

    private Label id;

    private Label idLabel;

    private Label author;

    private InMemorySource.Filter<Pipeline> canRunPipelineFilter;

    /**
     * The constructor should first build the main layout, set the composition
     * root and then do any custom initialization.
     * The constructor will not be automatically regenerated by the visual
     * editor.
     */
    public SchedulePipeline() {
        this.setResizable(false);
        this.setModal(true);
        this.setCaption(Messages.getString("SchedulePipeline.schedule"));
        this.addCloseListener(new Window.CloseListener() {
            @Override
            public void windowClose(CloseEvent e) {
                resetURL();
            }
        });
    }

    /**
     * Initialize the component.
     */
    public void init() {
        buildMainLayout();
        this.setContent(mainLayout);
        setSizeUndefined();
        isInitialized = true;
    }

    /**
     * Is initialized.
     *
     * @return If is initialized
     */
    public boolean isInitialized() {
        return isInitialized;
    }

    /**
     * Sets the corresponding value of Pipeline to the dialog.
     *
     * @param selectedPipeline
     */
    public void setSelectePipeline(Pipeline selectedPipeline) {
        tabSheet.setSelectedTab(0);

        comboPipeline.setValue(selectedPipeline.getId());
        scheduleDescription.setValue("");
        scheduleType.setValue(ScheduleType.PERIODICALLY);
        date.setValue(new Date());
        justOnce.setValue(false);
        intervalOption.setValue(PeriodUnit.DAY);
        strictlyTimed.setValue(false);
        comboEvery.setValue(PeriodUnit.DAY);
        valueInt.setValue(1);
        valueTol.setValue(1);
        notifyThis.setValue(true);
        emailNotifications.getDefaultScheduleNotificationRecord();
        email.getUserEmailNotification(authCtx.getUser());
        emailNotifications.setDisableComponents();

        source.loadData(dbPipeline);
        sourceCombo.loadData(dbPipeline);
        source.hide(selectedPipeline.getId(), true);
        if (selectPipe != null) {
            selectPipe.setValue(null);
        }

    }

    /**
     * Selects given schedule and displays it.
     *
     * @param selectedSchedule
     */
    public void setSelectedSchedule(Schedule selectedSchedule) {
        tabSheet.setSelectedTab(0);

        if (selectedSchedule == null) {
            selectSch = null;
            scheduleDescription.setValue("");
            setIdValue(null);
            this.author.setValue(getScheduleAuthorDisplayName(selectedSchedule));
            comboPipeline.setValue(null);
            scheduleType.setValue(ScheduleType.PERIODICALLY);
            date.setValue(new Date());
            justOnce.setValue(false);
            intervalOption.setValue(PeriodUnit.DAY);
            strictlyTimed.setValue(false);
            comboEvery.setValue(PeriodUnit.DAY);
            valueInt.setValue(1);
            valueTol.setValue(1);
            notifyThis.setValue(true);
            emailNotifications.getDefaultScheduleNotificationRecord();
            email.getUserEmailNotification(authCtx.getUser());
            emailNotifications.setDisableComponents();
            source.loadData(dbPipeline);
            sourceCombo.loadData(dbPipeline);
            this.sourceCombo.filter(this.isInitialized, this.canRunPipelineFilter);

            if (selectPipe != null) {
                selectPipe.setValue(null);
            }

        } else {

            //setting name
            scheduleDescription.setValue(selectedSchedule.getDescription());
            setIdValue(selectedSchedule.getId());
            //setting pipeline
            comboPipeline.setValue(selectedSchedule.getPipeline().getId());
            //setting scheduling rule type
            scheduleType.setValue(selectedSchedule.getType());
            this.author.setValue(getScheduleAuthorDisplayName(selectedSchedule));
            //PERIODICALLY type
            if (selectedSchedule.getType().equals(ScheduleType.PERIODICALLY)) {
                //setting the date
                date.setValue(selectedSchedule.getFirstExecution());
                //setting just ones parameter
                if (selectedSchedule.isJustOnce()) {
                    justOnce.setValue(true);

                } //setting period of repeat
                else {
                    justOnce.setValue(false);
                    if (((selectedSchedule.getPeriodUnit().equals(PeriodUnit.DAY))
                            || (selectedSchedule.getPeriodUnit()
                                    .equals(PeriodUnit.WEEK)) || (selectedSchedule
                                .getPeriodUnit().equals(PeriodUnit.MONTH)))
                            && (selectedSchedule.getPeriod().equals(1))) {
                        intervalOption.setValue(selectedSchedule.getPeriodUnit());
                    } else {
                        intervalOption.setValue("every");
                        comboEvery.setValue(selectedSchedule.getPeriodUnit());
                        valueInt.setValue(selectedSchedule.getPeriod());
                    }

                }

                strictlyTimed.setValue(selectedSchedule.isStrictlyTimed());
                if (selectedSchedule.isStrictlyTimed()) {
                    valueTol.setValue(selectedSchedule.getStrictToleranceMinutes());
                }
                source.loadData(dbPipeline);
                this.sourceCombo.loadData(this.dbPipeline);
                this.sourceCombo.filter(this.isInitialized, this.canRunPipelineFilter);

            } //AFTER_PIPELINE type
            else {
                //setting after_pipeline list
                Set<Pipeline> after = selectedSchedule.getAfterPipelines();
                List<Long> afterNames = new ArrayList<>();
                for (Pipeline afteritem : after) {
                    afterNames.add(afteritem.getId());
                }
                selectPipe.setValue(afterNames);
                source.loadData(dbPipeline);
                this.sourceCombo.loadData(this.dbPipeline);
                this.sourceCombo.filter(this.isInitialized, this.canRunPipelineFilter);
                source.hide(selectedSchedule.getPipeline().getId(), true);

            }

            if (selectedSchedule.getNotification() != null) {
                notifyThis.setValue(false);
                emailNotifications.getScheduleNotificationRecord(selectedSchedule);
                email.getScheduleEmailNotification(selectedSchedule);
            } else {
                notifyThis.setValue(true);
                emailNotifications.getDefaultScheduleNotificationRecord();
                email.getUserEmailNotification(authCtx.getUser());
                emailNotifications.setDisableComponents();

            }

            selectSch = selectedSchedule;
        }

    }

    /**
     * Builds main layout contains pipeline, the type of pipeline scheduling,
     * layouts with components for setting each of the type.
     *
     * @return mainLayout GridLayout with all dialog components
     */
    @AutoGenerated
    private VerticalLayout buildMainLayout() {

        mainLayout = new VerticalLayout();
        mainLayout.setImmediate(false);
        mainLayout.setSpacing(true);

        tabSheet = new TabSheet();
        tabSheet.setImmediate(true);

        tabSheet.addSelectedTabChangeListener(new SelectedTabChangeListener() {
            private static final long serialVersionUID = 1L;

            @Override
            public void selectedTabChange(SelectedTabChangeEvent event) {

                if (event.getTabSheet().getSelectedTab().equals(coreLayout)) {

                    tabSheet.setWidth(570, Unit.PIXELS);
                } else {
                    tabSheet.setWidth(440, Unit.PIXELS);
                }

            }
        });

        coreLayout = new GridLayout(1, 4);
        coreLayout.setWidth(100, Unit.PERCENTAGE);
        coreLayout.setImmediate(false);
        coreLayout.setSpacing(true);
        coreLayout.setMargin(true);

        this.canRunPipelineFilter = createRunPipelineFilter();

        source = new DbInMemorySource<>(new PipelineNameAccessor(), dbPipeline);
        container = new ReadOnlyContainer<>(source);

        sourceCombo = new DbInMemorySource<>(new PipelineNameAccessor(), dbPipeline);
        this.sourceCombo.filter(this.isInitialized, this.canRunPipelineFilter);
        containerCombo = new ReadOnlyContainer<>(sourceCombo);

        GridLayout layoutPipeline = new GridLayout(2, 4);
        layoutPipeline.setSpacing(true);
        layoutPipeline.setMargin(false);

        //Pipeline component
        comboPipeline = new ComboBox();
        comboPipeline.setImmediate(true);
        comboPipeline.setContainerDataSource(containerCombo);
        comboPipeline.setNullSelectionAllowed(false);
        comboPipeline.setItemCaptionPropertyId("name");
        //setting mandatory for the pipeline component
        comboPipeline.addValidator(new Validator() {
            private static final long serialVersionUID = 1L;

            @Override
            public void validate(Object value) throws InvalidValueException {
                if (value != null) {
                    return;
                }
                throw new InvalidValueException(Messages.getString("SchedulePipeline.pipeline.empty"));
            }
        });

        comboPipeline.addValueChangeListener(new ValueChangeListener() {
            /**
             * If scheduling type is AFTER_PIPELINE, then refreshing list of
             * pipelines in the after_pipeline component. It should not contain
             * selected for scheduling pipeline.
             */
            private static final long serialVersionUID = 1L;

            @Override
            public void valueChange(ValueChangeEvent event) {

                if (event.getProperty().getValue() != null) {

                    if (oldPipelineId != 0) {
                        source.show(oldPipelineId);
                    }
                    source.hide((long) event.getProperty().getValue(), true);
                    oldPipelineId = (long) event.getProperty().getValue();
                } else {
                    if (oldPipelineId != 0) {
                        source.show(oldPipelineId);
                    }
                    oldPipelineId = 0;
                }

                if (scheduleType.getValue().equals(ScheduleType.AFTER_PIPELINE)) {

                    coreLayout.removeComponent(0, 3);
                    afterLayout = buildAfterLayout();
                    coreLayout.addComponent(afterLayout, 0, 3);
                }
            }
        });
        comboPipeline.setWidth("460px");

        idLabel = new Label(Messages.getString("SchedulePipeline.id"));
        layoutPipeline.addComponent(idLabel, 0, 3);
        id = new Label(Messages.getString("SchedulePipeline.new"));
        layoutPipeline.addComponent(id, 1, 3);

        layoutPipeline.addComponent(new Label(Messages.getString("SchedulePipeline.pipeline")), 0, 0);
        layoutPipeline.addComponent(comboPipeline, 1, 0);

        layoutPipeline.addComponent(new Label(Messages.getString("SchedulePipeline.description")), 0, 1);
        scheduleDescription = new TextArea();
        scheduleDescription.setImmediate(true);
        scheduleDescription.setWidth("460px");
        layoutPipeline.addComponent(scheduleDescription, 1, 1);

        layoutPipeline.addComponent(new Label(Messages.getString("SchedulePipeline.scheduled.by")), 0, 2);
        author = new Label();
        layoutPipeline.addComponent(author, 1, 2);

        coreLayout.addComponent(layoutPipeline, 0, 0);

        //Schedule type component. Two types: PERIODICALLY and AFTER_PIPELINE
        scheduleType = new OptionGroup();
        scheduleType.setImmediate(true);
        scheduleType.addItem(ScheduleType.PERIODICALLY);
        scheduleType.addItem(ScheduleType.AFTER_PIPELINE);
        scheduleType.setValue(ScheduleType.PERIODICALLY);
        scheduleType
                .setItemCaption(ScheduleType.PERIODICALLY,
                        Messages.getString("SchedulePipeline.schedule.periodically"));
        scheduleType.setItemCaption(ScheduleType.AFTER_PIPELINE,
                Messages.getString("SchedulePipeline.schedule.after"));
        scheduleType.addValueChangeListener(new ValueChangeListener() {
            /**
             * For each type will be shown corresponding layout with components
             * for scheduling rule settings.
             */
            private static final long serialVersionUID = 1L;

            @Override
            public void valueChange(ValueChangeEvent event) {

                if (event.getProperty().getValue() == ScheduleType.AFTER_PIPELINE) {

                    coreLayout.removeComponent(0, 3);
                    afterLayout = buildAfterLayout();
                    coreLayout.addComponent(afterLayout, 0, 3);

                } else {
                    coreLayout.removeComponent(0, 3);
                    coreLayout.addComponent(autoLayout, 0, 3);
                }

            }
        });

        coreLayout.addComponent(scheduleType, 0, 2);
        autoLayout = buildAutoLayout();
        coreLayout.addComponent(autoLayout, 0, 3);

        //Layout with buttons Save and Cancel
        HorizontalLayout buttonBar = new HorizontalLayout();
        buttonBar.setMargin(true);

        //Save button
        Button createRule = new Button();
        createRule.setCaption(Messages.getString("SchedulePipeline.save"));
        createRule.setWidth("90px");
        createRule.setImmediate(true);
        createRule.addClickListener(new ClickListener() {
            /**
             * Checks validation of mandatory fields. Gets settings of
             * scheduling rule and store record to the Database.
             */
            private static final long serialVersionUID = 1L;

            @Override
            public void buttonClick(ClickEvent event) {

                email.saveEditedTexts();

                String errors = "";
                //pipeline should be filled
                try {
                    comboPipeline.validate();

                } catch (Validator.InvalidValueException e) {
                    errors = errors + e.getMessage();
                }

                //Interval and Tolerance of PERIODICALLY type should be positive number
                if (scheduleType.getValue().equals(ScheduleType.PERIODICALLY)) {
                    try {
                        tfEvery.validate();

                    } catch (Validator.InvalidValueException e) {
                        if (!errors.equals("")) {
                            errors = errors + Messages.getString("SchedulePipeline.interval.positive") + tfEvery.getValue() + "\"";
                        } else {
                            errors = errors + Messages.getString("SchedulePipeline.interval.positive2") + tfEvery.getValue() + "\"";
                        }
                    }

                    try {
                        tfTolerance.validate();

                    } catch (Validator.InvalidValueException e) {
                        if (!errors.equals("")) {
                            errors = errors + Messages.getString("SchedulePipeline.tolerance.positive") + tfTolerance.getValue() + "\"";
                        } else {
                            errors = errors + Messages.getString("SchedulePipeline.tolerance.positive2") + tfTolerance.getValue() + "\"";
                        }
                    }

                }
                //selected pipeline in the AFTER_PIPELINE case should be filled.
                if (scheduleType.getValue()
                        .equals(ScheduleType.AFTER_PIPELINE)) {
                    try {
                        selectPipe.validate();

                    } catch (Validator.InvalidValueException e) {
                        if (!errors.equals("")) {
                            errors = errors + "; " + e.getMessage();
                        } else {
                            errors = errors + e.getMessage();
                        }
                    }
                }

                if (!errors.equals("")) {
                    errors = errors + ".";
                    Notification.show(Messages.getString("SchedulePipeline.create.rule.failed"),
                            errors + Messages.getString("SchedulePipeline.create.rule.failed.description"), Notification.Type.ERROR_MESSAGE);
                    return;
                }

                //checking if the dialog was open from the Scheduler table
                //if no, create new scheduling rule
                if (selectSch == null) {
                    schedule = scheduleFacade.createSchedule();
                } else {
                    schedule = selectSch;
                    selectSch = null;
                }

                Object pipeID = comboPipeline.getValue();

                //setting scheduler parameters
                //setting pipeline
                Pipeline pipe = pipelineFacade.getPipeline((Long) pipeID);
                schedule.setPipeline(pipe);

                //setting description
                if (scheduleDescription.getValue() != null
                        && scheduleDescription.getValue().trim() != null) {
                    schedule.setDescription(scheduleDescription.getValue());
                } else {
                    schedule.setDescription("");
                }

                //setting type
                schedule.setType((ScheduleType) scheduleType.getValue());

                // Periodically Schedule type selected. Setting parameters.
                if (scheduleType.getValue().equals(ScheduleType.PERIODICALLY)) {
                    schedule.setFirstExecution(date.getValue());
                    schedule.setJustOnce(justOnce.getValue());
                    if (justOnce.getValue().equals(false)) {

                        if ((intervalOption.getValue().equals(PeriodUnit.DAY))
                                || (intervalOption.getValue()
                                        .equals(PeriodUnit.WEEK))
                                || (intervalOption.getValue()
                                        .equals(PeriodUnit.MONTH))) {

                            schedule.setPeriodUnit((PeriodUnit) intervalOption
                                    .getValue());
                            schedule.setPeriod(1);

                        } else {
                            schedule.setPeriodUnit((PeriodUnit) comboEvery
                                    .getValue());
                            schedule.setPeriod(valueInt.getValue());
                        }
                    }
                    schedule.setStrictlyTimed(strictlyTimed.getValue());
                    if (strictlyTimed.getValue().equals(true)) {
                        schedule.setStrictToleranceMinutes(valueTol.getValue());
                    }

                } // After pipeline Schedule type selected Setting parameters.
                else {
                    Set<Object> selectedPipelines = (Set) selectPipe.getValue();
                    Iterator<Object> it = selectedPipelines.iterator();
                    afterPipelines = new HashSet<>();
                    while (it.hasNext()) {
                        Object selectPipe = it.next();
                        Pipeline item = pipelineFacade.getPipeline((Long) selectPipe);
                        afterPipelines.add(item);
                    }
                    schedule.setAfterPipelines(afterPipelines);
                    schedule.setJustOnce(true);
                    schedule.setFirstExecution(null);
                    schedule.setPeriodUnit(null);
                    schedule.setPeriod(null);
                }
                schedule.setEnabled(true);

//				// store scheduling rule record to DB
//				scheduleFacade.save(schedule);
//				Notification.show(String.format("Pipeline %s scheduled successfuly!", schedule.getPipeline().getName()), Notification.Type.HUMANIZED_MESSAGE);
                if (notifyThis.getValue().equals(false)) {

                    if (getEmailLayout().isEnabled()) {

                        String errorText = emailValidation();

                        if (!errorText.equals("")) {
                            Notification.show(Messages.getString("SchedulePipeline.settings.save.failed"), errorText, Notification.Type.ERROR_MESSAGE);
                            return;
                        }
                    }
                    ScheduleNotificationRecord notification = schedule.getNotification();
                    if (notification != null) {

                        emailNotifications.setScheduleNotificationRecord(notification, schedule);
                        email.setScheduleEmailNotification(notification, schedule);
                        schedule.setNotification(notification);
                    } else {

                        ScheduleNotificationRecord scheduleNotificationRecord = new ScheduleNotificationRecord();
                        emailNotifications.setScheduleNotificationRecord(scheduleNotificationRecord, schedule);
                        email.setScheduleEmailNotification(scheduleNotificationRecord, schedule);
                        schedule.setNotification(scheduleNotificationRecord);

                    }

                    ScheduledJobsPriority job = (ScheduledJobsPriority) priorityComboBox.getValue();
                    Long priority = job.getValue();
                    schedule.setPriority(priority);
                    // store scheduling rule record to DB
                    scheduleFacade.save(schedule);
                    Notification.show(Messages.getString("SchedulePipeline.save.success", schedule.getPipeline().getName()), Notification.Type.HUMANIZED_MESSAGE);

                } else {
                    if (schedule.getNotification() != null) {
                        scheduleFacade.deleteNotification(schedule.getNotification());
                    } else {
                        // store scheduling rule record to DB
                        ScheduledJobsPriority job = (ScheduledJobsPriority) priorityComboBox.getValue();
                        Long priority = job.getValue();
                        schedule.setPriority(priority);
                        scheduleFacade.save(schedule);
                        Notification.show(Messages.getString("SchedulePipeline.save.success", schedule.getPipeline().getName()), Notification.Type.HUMANIZED_MESSAGE);

                    }
                }
                resetURL();
                close();

            }
        });

        buttonBar.addComponent(createRule);

        Button cancelButton = new Button(Messages.getString("SchedulePipeline.cancel"), new Button.ClickListener() {
            /**
             * Closes Scheduling pipeline window
             */
            private static final long serialVersionUID = 1L;

            @Override
            public void buttonClick(Button.ClickEvent event) {
                resetURL();
                close();

            }
        });
        cancelButton.setWidth("90px");
        buttonBar.addComponent(cancelButton);

        VerticalLayout notificationsLayout = buildnotificationsLayout();
        tabSheet.addTab(coreLayout, Messages.getString("SchedulePipeline.core"), null);
        if (this.permissionUtils.hasUserAuthority("userNotificationSettings.createPipelineExecutionSettings")) {

            tabSheet.addTab(notificationsLayout, Messages.getString("SchedulePipeline.notifications"), null);
        }
        mainLayout.addComponent(tabSheet);
        mainLayout.addComponent(buttonBar);
//		mainLayout.setComponentAlignment(buttonBar, Alignment.MIDDLE_RIGHT);

        return mainLayout;
    }

    private VerticalLayout buildnotificationsLayout() {

        VerticalLayout notificationsLayout = new VerticalLayout();
        notificationsLayout.setMargin(true);
        notificationsLayout.setSpacing(true);
        notificationsLayout.setImmediate(true);

        emailNotifications = new EmailNotifications();
        emailNotifications.parentComponentSh = this;
        notificationsLayout = emailNotifications.buildEmailNotificationsLayout();

        email = new EmailComponent();
        setEmailLayout(new GridLayout());
        setEmailLayout(email.initializeEmailList());
        notificationsLayout.addComponent(getEmailLayout());
        email.getUserEmailNotification(authCtx.getUser());

        notifyThis = new CheckBox();
        notifyThis.setImmediate(true);
        notifyThis.setCaption(Messages.getString("SchedulePipeline.use.default"));
        notificationsLayout.addComponent(notifyThis, 0);
        emailNotifications.setDisableComponents();
        getEmailLayout().setEnabled(false);
        notifyThis.addValueChangeListener(new ValueChangeListener() {
            private static final long serialVersionUID = 1L;

            @Override
            public void valueChange(ValueChangeEvent event) {

                if (event.getProperty().getValue().equals(true)) {
                    emailNotifications.setDisableComponents();

                } else {
                    emailNotifications.setEnableComponents();
                }

            }
        });
        notifyThis.setValue(true);

        return notificationsLayout;

    }

    /**
     * Building layout for the AFTER_PIPELINE scheduling type. Calls from {@link #buildMainLayout} in case of {@link #scheduleType} is setting as
     * {@link ScheduleType#AFTER_PIPELINE}
     *
     * @return afterLayout GridLayout with components that designed for setting
     *         schedule the pipeline to run after selected pipelines finish.
     */
    private GridLayout buildAfterLayout() {

        afterLayout = new GridLayout(2, 1);
        afterLayout.setImmediate(false);
//		afterLayout.setHeight("400px");
        afterLayout.setSpacing(true);
        afterLayout.setColumnExpandRatio(0, 0.2f);
        afterLayout.setColumnExpandRatio(1, 0.8f);
        afterLayout.setStyleName("scheduling");

        afterLayout.addComponent(new Label(Messages.getString("SchedulePipeline.pipeline.select")), 0, 0);

        VerticalLayout selectPipelineLayout = new VerticalLayout();
        selectPipelineLayout.setSpacing(true);

        pipeFilter = new TextField();
        pipeFilter.setImmediate(false);
        pipeFilter.setInputPrompt(Messages.getString("SchedulePipeline.pipeline.filter"));
        pipeFilter.setWidth("140px");
        pipeFilter.setTextChangeEventMode(TextChangeEventMode.LAZY);
        pipeFilter.addTextChangeListener(new FieldEvents.TextChangeListener() {
            /**
             * Filtering by pipeline name in the selectPipe component.
             */
            private static final long serialVersionUID = 1L;

            SimpleTreeFilter filter = null;

            @Override
            public void textChange(final FieldEvents.TextChangeEvent event) {
                Container.Filterable f = (Container.Filterable) selectPipe
                        .getContainerDataSource();

                // Remove old filter
                if (filter != null) {
                    f.removeContainerFilter(filter);
                }

                // Set new filter
                filter = new SimpleTreeFilter(event.getText(), true, false);
                f.addContainerFilter(filter);

                // update filters
                source.showAll();

                source.filter(isInitialized, new InMemorySource.Filter<Pipeline>() {
                    @Override
                    public boolean filter(Pipeline object) {
                        return StringUtils.containsIgnoreCase(object.getName(),
                                event.getText());
                    }
                });

                // refresh the twin container
                container.refresh();
            }
        });

        selectPipelineLayout.addComponent(pipeFilter);

        //Component for pipelines select
        selectPipe = new TwinColSelect();
        //getting all pipelines to the left column
//		for (Pipeline item : pipelines) {
//			if (item.getId() != comboPipeline.getValue()) {
//				selectPipe.addItem(item.getName());
        selectPipe.setContainerDataSource(container);
//			}
//		}

        selectPipe.setNullSelectionAllowed(true);
        selectPipe.setMultiSelect(true);
        selectPipe.setImmediate(true);
        selectPipe.setWidth("400px");
        selectPipe.setHeight("200px");
        selectPipe.setItemCaptionPropertyId("name");
        selectPipe.setLeftColumnCaption(Messages.getString("SchedulePipeline.pipelines.available"));
        selectPipe.setRightColumnCaption(Messages.getString("SchedulePipeline.pipelines.selected"));
        //selectPipe is mandatory component
        selectPipe.addValidator(new Validator() {
            private static final long serialVersionUID = 1L;

            @Override
            public void validate(Object value) throws InvalidValueException {

                if (!value.toString().equals("[]")) {
                    return;
                }
                throw new InvalidValueException(
                        Messages.getString("SchedulePipeline.pipelines.selected.empty"));

            }
        });

        selectPipelineLayout.addComponent(selectPipe);
        afterLayout.addComponent(selectPipelineLayout, 1, 0);

        return afterLayout;

    }

    /**
     * Building layout for the PERIODICALLY scheduling type. Calls from {@link #buildMainLayout} in case of {@link #scheduleType} is setting as
     * {@link ScheduleType#PERIODICALLY}
     *
     * @return autoLayout GridLayout with components that designed for setting
     *         schedule the pipeline to run automatically in fixed interval.
     */
    @SuppressWarnings({ "static-access", "deprecation" })
    private HorizontalLayout buildAutoLayout() {

        autoLayout = new HorizontalLayout();
        autoLayout.setImmediate(true);
        autoLayout.setSpacing(true);
//		autoLayout.setHeight("450px");
        autoLayout.setWidth(100, Unit.PERCENTAGE);
        autoLayout.setStyleName("scheduling");

        VerticalLayout firstExecutionLayout = new VerticalLayout();
        firstExecutionLayout.setSpacing(true);

        //Date component
        firstExecutionLayout.addComponent(new Label(Messages.getString("SchedulePipeline.date.and.time.execution")));

        date = new InlineDateField();
        date.setValue(new java.util.Date());
        date.setResolution(date.RESOLUTION_SEC);
        firstExecutionLayout.addComponent(date);

        //Just ones component. Used if the pipeline will be run only ones
        justOnce = new CheckBox();
        justOnce.setCaption(Messages.getString("SchedulePipeline.once"));
        justOnce.setValue(false);
        justOnce.setImmediate(true);
        justOnce.addValueChangeListener(new ValueChangeListener() {
            /**
             * If justOnce is selected then the OptionGroup inervalLayout is
             * disabled.
             */
            private static final long serialVersionUID = 1L;

            @Override
            public void valueChange(ValueChangeEvent event) {
                if (event.getProperty().getValue().equals(true)) {
                    inervalLayout.setEnabled(false);
                    if (!tfEvery.isValid()) {
                        tfEvery.setValue("1");
                    }
                } else {
                    inervalLayout.setEnabled(true);
                }

            }
        });

        firstExecutionLayout.addComponent(justOnce);

        VerticalLayout dateIntervalLayout = new VerticalLayout();
        dateIntervalLayout.setSpacing(true);

        dateIntervalLayout.addComponent(new Label(Messages.getString("SchedulePipeline.interval")));

        //OptionGroup with an interval
        inervalLayout = new VerticalLayout();
        intervalOption = new OptionGroup();
        intervalOption.setImmediate(true);
        intervalOption.addItem(PeriodUnit.DAY);
        intervalOption.setItemCaption(PeriodUnit.DAY, Messages.getString("SchedulePipeline.every.day"));
        intervalOption.addItem(PeriodUnit.WEEK);
        intervalOption.setItemCaption(PeriodUnit.WEEK, Messages.getString("SchedulePipeline.every.week"));
        intervalOption.addItem(PeriodUnit.MONTH);
        intervalOption.setItemCaption(PeriodUnit.MONTH, Messages.getString("SchedulePipeline.every.month"));
        intervalOption.addItem("every");
        intervalOption.setItemCaption("every", Messages.getString("SchedulePipeline.every"));
        intervalOption.setValue(PeriodUnit.DAY);
        intervalOption.addValueChangeListener(new ValueChangeListener() {
            /**
             * If selected "every" then will be enable component for setting
             * nonstandard interval.
             */
            private static final long serialVersionUID = 1L;

            @Override
            public void valueChange(ValueChangeEvent event) {

                if (event.getProperty().getValue().toString().equals("every")) {

                    comboEvery.setEnabled(true);
                    tfEvery.setEnabled(true);

                } else {

                    comboEvery.setEnabled(false);
                    if (!tfEvery.isValid()) {
                        tfEvery.setValue("1");
                    }
                    tfEvery.setEnabled(false);
                }

            }
        });
        inervalLayout.addComponent(intervalOption);

        //layout for the component for setting nonstandard interval.
        //contains text field for setting numbers and combobox with period values.
        inervalEveryLayout = new HorizontalLayout();
        inervalEveryLayout.setSpacing(true);
        inervalEveryLayout.setMargin(true);

        valueInt = new ObjectProperty<>(1);
        tfEvery = new TextField(valueInt);
        tfEvery.setConverter(Integer.class);
        tfEvery.setWidth("50px");
        tfEvery.setImmediate(true);
        tfEvery.setEnabled(false);
        tfEvery.addValidator(new Validator() {
            private static final long serialVersionUID = 1L;

            @Override
            public void validate(Object val) throws InvalidValueException {
                if (((Integer) val != null) && ((Integer) val > 0)) {
                    return;
                }
                throw new InvalidValueException(Messages.getString("SchedulePipeline.value.positive"));

            }
        });

        inervalEveryLayout.addComponent(tfEvery);

        comboEvery = new ComboBox();
        comboEvery.setNullSelectionAllowed(false);
        comboEvery.setImmediate(true);
        comboEvery.addItem(PeriodUnit.MINUTE);
        comboEvery.setItemCaption(PeriodUnit.MINUTE, Messages.getString("SchedulePipeline.minutes"));
        comboEvery.addItem(PeriodUnit.HOUR);
        comboEvery.setItemCaption(PeriodUnit.HOUR, Messages.getString("SchedulePipeline.hours"));
        comboEvery.addItem(PeriodUnit.DAY);
        comboEvery.setItemCaption(PeriodUnit.DAY, Messages.getString("SchedulePipeline.days"));
        comboEvery.addItem(PeriodUnit.MONTH);
        comboEvery.setItemCaption(PeriodUnit.MONTH, Messages.getString("SchedulePipeline.months"));
        comboEvery.setValue(PeriodUnit.DAY);
        comboEvery.setEnabled(false);
        comboEvery.setTextInputAllowed(false);

        inervalEveryLayout.addComponent(comboEvery);
        inervalLayout.addComponent(inervalEveryLayout);
        dateIntervalLayout.addComponent(inervalLayout);

        //strictly timed component
        strictlyTimedLayout = new VerticalLayout();
        strictlyTimedLayout.setSpacing(true);

        strictlyTimed = new CheckBox();
        strictlyTimed.setCaption(Messages.getString("SchedulePipeline.timed.strictly"));
        strictlyTimed.setValue(false);
        strictlyTimed.setImmediate(true);
        strictlyTimed.addValueChangeListener(new ValueChangeListener() {
            /**
             * If strictlytimed isn't selected then the tolerance cpmponent is
             * disabled.
             */
            private static final long serialVersionUID = 1L;

            @Override
            public void valueChange(ValueChangeEvent event) {
                if (event.getProperty().getValue().equals(false)) {
                    toleranceLayout.setEnabled(false);

                } else {

                    toleranceLayout.setEnabled(true);

                }

            }
        });

        strictlyTimedLayout.addComponent(strictlyTimed);

        priorityLayout = new VerticalLayout();

        toleranceLayout = new HorizontalLayout();
        toleranceLayout.setSpacing(true);
        toleranceLayout.setEnabled(false);
        toleranceLayout.addComponent(new Label(Messages.getString("SchedulePipeline.tolerance")));

        valueTol = new ObjectProperty<>(1);
        tfTolerance = new TextField(valueTol);
        tfTolerance.setConverter(Integer.class);
        tfTolerance.setWidth("50px");
        tfTolerance.setImmediate(true);
        tfTolerance.addValidator(new Validator() {
            private static final long serialVersionUID = 1L;

            @Override
            public void validate(Object val) throws InvalidValueException {
                if (((Integer) val != null) && ((Integer) val > 0)) {
                    return;
                }
                throw new InvalidValueException(Messages.getString("SchedulePipeline.positive.value"));

            }
        });

        toleranceLayout.addComponent(tfTolerance);

        toleranceLayout.addComponent(new Label(Messages.getString("SchedulePipeline.value.minutes")));

        priorityComboBox = new ComboBox();
        priorityComboBox.setNullSelectionAllowed(false);
        priorityComboBox.setTextInputAllowed(false);
        priorityComboBox.setImmediate(true);
        // Add some items
        for (ScheduledJobsPriority job : ScheduledJobsPriority.values()) {
            priorityComboBox.addItem(job);
        }

        priorityComboBox.setValue(ScheduledJobsPriority.HIGHEST);
        HorizontalLayout priorityComboBoxLayout = new HorizontalLayout();

        Label priorityLabel = new Label(Messages.getString("SchedulePipeline.priority"));
        priorityComboBoxLayout.addComponent(priorityLabel);

        Label priorityDescription = new Label(ScheduledJobsPriority.IGNORE.name()
                + Messages.getString("SchedulePipeline.immediate.start"));
        priorityDescription.setWidth(100, Unit.PERCENTAGE);
        priorityComboBoxLayout.addComponent(priorityComboBox);
        priorityComboBoxLayout.setComponentAlignment(priorityComboBox, Alignment.BOTTOM_RIGHT);

        priorityLayout.addComponent(priorityComboBoxLayout);
        priorityLayout.addComponent(priorityDescription);

        strictlyTimedLayout.addComponent(toleranceLayout);
        dateIntervalLayout.addComponent(strictlyTimedLayout);
        if (this.permissionUtils.hasUserAuthority("scheduleRule.setPriority")) {
            dateIntervalLayout.addComponent(priorityLayout);
        }
        autoLayout.addComponent(firstExecutionLayout);
        autoLayout.addComponent(dateIntervalLayout);

        return autoLayout;

    }

    /**
     * Creating error message in case of wrong email format or duplicate emails
     * in Notification tab
     *
     * @return String with error message
     */
    private String emailValidation() {

        String errorText = "";
        String wrongFormat = "";
        String duplicate = "";
        boolean notEmpty = false;
        boolean dupl = true;
        int errorNumber = 0;
        int duplicateNumber = 0;
        List<TextField> duplicateEmails = new ArrayList<>();
        for (TextField emailField : email.listedEditText) {
            if (!emailField.getValue().trim().isEmpty()) {
                notEmpty = true;
                break;
            }
        }

        if (notEmpty) {
            for (TextField emailField : email.listedEditText) {

                try {
                    emailField.validate();

                } catch (Validator.InvalidValueException e) {

                    if (e.getMessage().equals("wrong е-mail format")) {
                        if (errorNumber == 0) {
                            wrongFormat = "\"" + emailField.getValue() + "\"";
                        } else {
                            wrongFormat = wrongFormat + ", " + "\"" + emailField.getValue() + "\"";
                        }
                        errorNumber++;
                    }
                    if (e.getMessage().equals("duplicate e-mail")) {

                        if (duplicateNumber == 0) {
                            duplicate = "\"" + emailField.getValue() + "\"";
                            duplicateEmails.add(emailField);
                            duplicateNumber++;

                        } else {

                            for (TextField duplicateField : duplicateEmails) {
                                if (emailField.getValue().equals(duplicateField.getValue())) {
                                    dupl = false;
                                    break;
                                }
                            }
                            if (dupl) {
                                duplicate = duplicate + ", " + "\"" + emailField.getValue() + "\"";
                                duplicateEmails.add(emailField);
                                duplicateNumber++;
                            }
                            dupl = true;
                        }

                    }
                }
            }
            if (errorNumber == 1) {
                errorText = Messages.getString("SchedulePipeline.email") + wrongFormat + Messages.getString("SchedulePipeline.format.wrong");
            }
            if (errorNumber > 1) {
                errorText = Messages.getString("SchedulePipeline.emails") + wrongFormat + Messages.getString("SchedulePipeline.emails.format.wrong");
            }
            if (duplicateNumber == 1) {
                errorText = errorText + Messages.getString("SchedulePipeline.email2") + duplicate + Messages.getString("SchedulePipeline.is.introduced");
            }
            if (duplicateNumber > 1) {
                errorText = errorText + Messages.getString("SchedulePipeline.emails2") + duplicate + Messages.getString("SchedulePipeline.are.introduced");
            }
        } else {
            errorText = Messages.getString("SchedulePipeline.email.at.least.once");
        }

        return errorText;

    }

    private void setIdValue(Long id) {
        boolean hasId = id != null;
        if (id != null) {
            this.id.setValue(id.toString());
        }
        this.id.setVisible(hasId);
        this.idLabel.setVisible(hasId);
    }

    /**
     * @return the emailLayout
     */
    public GridLayout getEmailLayout() {
        return emailLayout;
    }

    /**
     * @param emailLayout
     *            the emailLayout to set
     */
    public void setEmailLayout(GridLayout emailLayout) {
        this.emailLayout = emailLayout;
    }

    private InMemorySource.Filter<Pipeline> createRunPipelineFilter() {
        InMemorySource.Filter<Pipeline> filter = new InMemorySource.Filter<Pipeline>() {

            @Override
            public boolean filter(Pipeline pipeline) {
                return permissionUtils.hasPermission(pipeline, EntityPermissions.PIPELINE_RUN);
            }

        };

        return filter;
    }

    private String getScheduleAuthorDisplayName(Schedule schedule) {
        if (schedule != null) {
            String ownerDisplayName = (schedule.getOwner().getFullName() != null) ? schedule.getOwner().getFullName() : schedule.getOwner().getUsername();
            if (schedule.getActor() != null) {
                return ownerDisplayName + " (" + schedule.getActor().getName() + ")";
            }
            return ownerDisplayName;
        } else {
            String ownerDisplayName = (this.authCtx.getUser().getFullName() != null) ? this.authCtx.getUser().getFullName() : this.authCtx.getUsername();
            if (this.authCtx.getUser().getUserActor() != null) {
                return ownerDisplayName + " (" + this.authCtx.getUser().getUserActor().getName() + ")";
            }
            return ownerDisplayName;
        }
    }

    public void setPipeline(Long pipelineId) {
        if (pipelineId != null) {
            comboPipeline.setValue(pipelineId);
            comboPipeline.setEnabled(false);
        }
    }

    public void enableComboPipeline() {
        if (!comboPipeline.isEnabled()) {
            comboPipeline.setEnabled(true);
        }
    }

    private void resetURL() {
        String uriFragment = Page.getCurrent().getUriFragment();
        if (uriFragment.contains("New/")) {
            uriFragment = uriFragment.replace("New/", "");
        }
        ParametersHandler handler = new ParametersHandler(uriFragment);
        handler.removeParameter("schedule");
        handler.removeParameter("pipeline");
        ((AppEntry) UI.getCurrent()).setUriFragment(handler.getUriFragment(), false);
    }

}
